#!/usr/local/bin/python
#
# This script is the master script that generates the driver script that does
# the actual pipeline analysis.

# ORIGINAL IMSA_v2 file
# Protected by license (see IMSA_License.txt)



HELP_STRING = """
    Creates a pipeline script for the Arron Lab Solexa Analysis Pipeline.  This master script takes in the parameters
    for the dataset and creates a script to actually perform the analysis.  For documentation, read the README in this
    directory.
    
    Required:
        -i    Input file 1.  The first paired end of the Solexa results, or the only Solexa file for single end runs.
    
    Optional:
        -d    Delimiter.  Default=#0/.  A delimiter of "None" or "False" is used to indicate a single end run. 
        -j    Input file 2.  The second paired end of the Solexa results.
        -p    Analysis parameters.  A text file containing one line per analysis required.  See documentation for details.
        -a    Number of processors, or if USE_GRID is set to true, the number of cluster jobs to submit.
        -o    Offset.  Default=64.
"""

SCRIPT_OVERVIEW="""
#  Pipeline Script generated by %(user)s on %(day)s at %(time)s.
#  Input files are:
#      %(if1)s  -- a %(ff1)s file
#      %(if2)s  -- a %(ff2)s file
#  Script commands are:
#      %(act)s
#

# generic python modules
import os
import sys

# Arron Lab modules
sys.path.append("%(sd)s")
from %(pd)s import pipelineUtils
from %(pd)s import listener

# create a log file for this run
logFile = pipelineUtils.getLogListener()

"""

SCRIPT_CONVERT_FASTA = """
# converting FASTQ file '%(if)s' to FASTA file '%(of)s'
if not os.path.exists("%(of)s"):
    pipelineUtils.convertToFasta("%(if)s", "%(ot)s", logFile)
    os.rename("%(ot)s", "%(of)s")
"""

SCRIPT_COMBINE_FILES = """
# combine the two pairs into one file for easier blast/blat alignment and filtering.
if not os.path.exists("%(of)s"):
    pipelineUtils.combineFiles(["%(if1)s", "%(if2)s"], "%(ot)s")
    os.rename("%(ot)s", "%(of)s")
"""

SCRIPT_REMOVE_N = """
# removing reads with more than %(th)s N's from '%(if)s' and more than %(rth)s homopolymer repeats to create '%(of)s'
if not os.path.exists("%(of)s"):
    pipelineUtils.removeNs("%(if)s", "%(ot)s", %(th)s, %(rth)s, logFile)
    os.rename("%(ot)s", "%(of)s")

"""


SCRIPT_QUALITY_FILTER = """
# removing read pairs where both reads have more than %(nb)s bases with quality scores of %(t)s or less
if not os.path.exists("%(of1)s"):
    pipelineUtils.pairedQualityFilter("%(if1)s", "%(if2)s", "%(ot1)s", "%(ot2)s", %(nb)s, %(t)s, %(os)s, mylistener=logFile)
    os.rename("%(ot1)s", "%(of1)s")
    os.rename("%(ot2)s", "%(of2)s")
"""

SCRIPT_QUALITY_FILTER_SINGLE = """
# removing reads with more than %(nb)s bases with quality scores of %(t)s or less
if not os.path.exists("%(of1)s"):
    pipelineUtils.qualityFilter("%(if1)s", "%(ot1)s", %(nb)s, %(t)s, %(os)s, mylistener=logFile)
    os.rename("%(ot1)s", "%(of1)s")

"""

SCRIPT_BOWTIE = """
# Bowtie vs. '%(td)s'.  Hits are removed from the read set.
# Bowtie parameters: '%(bp)s'
# filter parameters: '%(fp)s'
if not os.path.exists("%(ofb)s"):
    pipelineUtils.runBowtie("%(if1)s", "%(if2)s", "%(td)s", "%(otb)s", "%(bp)s", "%(tmp)s", %(nn)s, "%(log)s", logFile)
    os.rename("%(otb)s", "%(ofb)s")
if not os.path.exists("%(off1)s"):
    pipelineUtils.filterUsingBowtie("%(if1)s", "%(if2)s", "%(ofb)s", inputType="%(ft)s", %(fp)s, divideHalf=%(dh)s, mylistener=logFile)
    os.rename("%(otf1)s", "%(off1)s")
"""


SCRIPT_BOWTIE_PAIR = """
    os.rename("%(otf2)s", "%(off2)s")

"""

SCRIPT_BOWTIE2 = """
# Bowtie2 vs. '%(td)s'.  Hits are removed from the read set.
# Bowtie2 parameters: '%(bp)s'
if not os.path.exists("%(ofb)s"):
    pipelineUtils.runBowtie2("%(if1)s", "%(if2)s", "%(td)s", "%(otb)s", "%(bp)s", "%(tmp)s", %(nn)s, "%(un)s", "%(log)s", logFile)
    os.rename("%(otb)s", "%(ofb)s")
"""

    
SCRIPT_BLAT = """
# BLAT vs. '%(td)s'.  Hits are removed from the read set.
# BLAT parameters: '%(bp)s'
# filter parameters: '%(fp)s'
if not os.path.exists("%(ofb)s"):
    pipelineUtils.runBlat("%(if)s", "%(td)s", "%(otb)s", "%(bp)s", "%(ooc)s", "%(tmp)s", %(nn)s, "%(log)s", logFile)
    os.rename("%(otb)s", "%(ofb)s")
if not os.path.exists("%(off)s"):
    pipelineUtils.filterUsingBlat("%(if)s", "%(ofb)s", %(fp)s, divideHalf=%(dh)s, mylistener=logFile)
    os.rename("%(otf)s", "%(off)s")

"""

SCRIPT_BLAST = """
# BLAST vs '%(td)s'.  Hits are removed from the read set.
# BLAST parameters: '%(bp)s'
# Filter paremeters: '%(fp)s'
if not os.path.exists("%(ofb)s"):
    pipelineUtils.runBlast("%(if)s", "%(td)s", "%(otb)s", "%(bp)s", "%(tmp)s", %(nn)s, "%(log)s", logFile)
    os.rename("%(otb)s", "%(ofb)s")
if not os.path.exists("%(off)s"):
    pipelineUtils.filterUsingBlast("%(if)s", "%(ofb)s", %(fp)s, mylistener=logFile)
    os.rename("%(otf)s", "%(off)s")
    
"""

SCRIPT_LZW = """
# Filtering with LZW ratio.  Reads with an LZW ratio less than %(th)s are removed.
if not os.path.exists("%(of)s"):
    pipelineUtils.runLZWfilter("%(if)s", "%(ot)s", "%(th)s", logFile)
    os.rename("%(ot)s", "%(of)s")
"""


# system imports
import sys
from getopt import getopt
import pipelineUtils
import os
import time
import getpass

# IMSA imports
import config

def main(argv=None):
    """The starting point for the code."""
    
    if argv is None:
        argv = sys.argv
        
    inputFile1 = None
    inputFile2 = None
    delimiter = config.DEFAULT_DELIMITER
    scriptActions = config.DEFAULT_ACTIONS
    numProcessors = config.DEFAULT_NUM_PROCESSORS
    offset = config.DEFAULT_QUALITY_OFFSET
        
    try:
        optlist, args = getopt(argv[1:], "hi:j:d:p:a:o:")
    except:
        print "Illegal option"
        print ""
        print HELP_STRING
        sys.exit(1)
        
    if len(optlist) == 0:
        print ""
        print HELP_STRING
        sys.exit(1)
        
    for (opt, opt_arg) in optlist:
        if opt == '-h':
            print ""
            print HELP_STRING
            sys.exit(1)
        elif opt == "-i":
            inputFile1 = opt_arg
        elif opt == "-j":
            inputFile2 = opt_arg
        elif opt == "-p":
            scriptActions = readScriptActions(opt_arg)
        elif opt == "-a":
            numProcessors = int(opt_arg)
        elif opt == "-d":
            if opt_arg == "False" or opt_arg == "None":
                delimiter = None
            else:
                delimiter = opt_arg
        elif opt == "-o":
            offset = int(opt_arg)

    if not inputFile1:
        print "You must specify an input file 1 (-i)"
        print ""
        sys.exit(1)

    if not inputFile2:
        delimiter = None

    createScript(inputFile1, inputFile2, scriptActions, numProcessors, delimiter, offset)
    
def createScript(inputFile1, inputFile2, scriptActions, numProcessors, delimiter, offset):
    # SET UP
    # determine the output directory
    outputDir = getOutputDir(inputFile1, inputFile2)
    
    # determine what type of file the input(s) are
    fileType1 = pipelineUtils.getFileType(inputFile1)
    fileType2 = None
    if fileType1 != pipelineUtils.FILE_TYPE_FASTQ and fileType1 != pipelineUtils.FILE_TYPE_FASTA:
        raise Exception("The input files must be FASTQ or FASTA files.  '%s' is a '%s' file." % (inputFile1, fileType1))
    if inputFile2:
        fileType2 = pipelineUtils.getFileType(inputFile2)
        if fileType1 != fileType2:
            raise Exception("InputFile1 and InputFile2 must have the same type.  '%s' is a '%s' file but '%s' is a '%s' file." % (
                inputFile1, fileType1, inputFile2, fileType2))
        if fileType2 != pipelineUtils.FILE_TYPE_FASTQ and fileType2 != pipelineUtils.FILE_TYPE_FASTA:
            raise Exception("The input files must be FASTQ or FASTA files.  '%s' is a '%s' file." % (inputFile2, fileType2))
    
    # use just the file names (not the directory) for all the processing since the script is local
    inputFile1 = os.path.basename(inputFile1)
    if inputFile2:
        inputFile2 = os.path.basename(inputFile2)

         
    # special case -- if input is fastq, save the name as a variable to used later in converting fasta back to fastq
    originalFastqName = None
    if fileType1 == pipelineUtils.FILE_TYPE_FASTQ:
        originalFastqName = inputFile1
            
    # initial script output set up
    scriptOutput = open(outputDir + "/pipelineScript.py", "w")
    writeHeader(scriptOutput, inputFile1, inputFile2, fileType1, 
                      fileType2, outputDir, scriptActions)
    
    # FOR EACH ACTION
    currentFile1 = inputFile1
    currentFileType1 = fileType1
    currentFile2 = inputFile2
    currentFileType2 = fileType2

    for line in scriptActions.split("\n"):
        pieces = line.strip().split(" ")
        if len(pieces) < 1:
            raise Exception("Line '%s' in the script commands cannot be interpreted." % line.strip())

        if pieces[0] == "quality":
            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTQ:
                raise Exception("Only FASTQ files can be quality filtered.  '%s' is a '%s' file." % (currentFile1, currentFileType1))

            if not currentFile2:
                currentFile1 = writeSingleQualityFilter(currentFile1, line, scriptOutput, offset)
                #raise Exception("There must be two files for the quality filter.  Either you only started with one file or the files have been combined in subsequent steps.  The quality filter should be the first step.")
            else:
                currentFile1, currentFile2 = writeQualityFilter(currentFile1, currentFile2, line, scriptOutput, offset)
        
        elif pieces[0] == "removeN":
            if currentFile2:
                currentFile1 = writeCombineFiles(currentFile1, currentFile2, scriptOutput)
                currentFile2 = currentFileType2 = None
            
            if currentFileType1 == pipelineUtils.FILE_TYPE_FASTQ:
                currentFile1 = writeConvertToFasta(currentFile1, scriptOutput)
                currentFileType1 = pipelineUtils.FILE_TYPE_FASTA                                

            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("Only FASTA files can have N's removed right now.  '%s' is a '%s' file." % (currentFile1, currentFileType1))

            currentFile1 = writeRemoveNs(currentFile1, line, scriptOutput)

        elif pieces[0] == "bowtie":
            
            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTQ and currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("For now, bowtie requires FASTQ or FASTA files. '%s' is a '%s' file." % (currentFile1,
                                                                                                    currentFileType1))
            currentFile1, currentFile2 = writeFilterFromBowtie(outputDir, currentFile1, currentFile2, currentFileType1, line,
                                                        numProcessors, scriptOutput, delimiter)

        elif pieces[0] == "bowtie2":
            
            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTQ and currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("For now, bowtie2 requires FASTQ or FASTA files. '%s' is a '%s' file." % (currentFile1,
                                                                                                    currentFileType1))
            currentFile1, currentFile2 = writeFilterFromBowtie2(outputDir, currentFile1, currentFile2, currentFileType1, line,
                                                        numProcessors, scriptOutput, delimiter)
            
            

        elif pieces[0] == "blast":
            if currentFile2:
                currentFile1 = writeCombineFiles(currentFile1, currentFile2, scriptOutput)
                currentFile2 = currentFileType2 = None

            if currentFileType1 == pipelineUtils.FILE_TYPE_FASTQ:
                currentFile1 = writeConvertToFasta(currentFile1, scriptOutput)
                currentFileType1 = pipelineUtils.FILE_TYPE_FASTA

            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("Only FASTA and FASTQ files can be blasted.  '%s' is a '%s' file." % (currentFile1,
                                                                                                      currentFileType1))
            
            currentFile1 = writeFilterFromBlast(outputDir, currentFile1, line, numProcessors, scriptOutput, delimiter)
            
        elif pieces[0] == "blat":
            if currentFile2:
                currentFile1 = writeCombineFiles(currentFile1, currentFile2, scriptOutput)
                currentFile2 = currentFileType2 = None

            if currentFileType1 == pipelineUtils.FILE_TYPE_FASTQ:
                currentFile1 = writeConvertToFasta(currentFile1, scriptOutput)
                currentFileType1 = pipelineUtils.FILE_TYPE_FASTA
            
            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("Only FASTA and FASTQ files can be blated.  '%s' is a '%s' file." % (currentFile1, currentFileType1))
            
            currentFile1 = writeFilterFromBlat(outputDir, currentFile1, line, numProcessors, scriptOutput, delimiter)
            
        elif pieces[0] == "lzw":
            if currentFile2:
                currentFile1 = writeCombineFiles(currentFile1, currentFile2, scriptOutput)
                currentFile2 = currentFileType2 = None
            
            if currentFileType1 != pipelineUtils.FILE_TYPE_FASTA:
                raise Exception("Only FASTA files can be filtered for lzw.  '%s' is a '%s' file." % (currentFile1, currentFileType1))
            
            currentFile1 = writeFilterLZW(currentFile1, line, scriptOutput)
             
        # add action to convert back to fastq
    
        else:
            raise Exception("The master.py script cannot yet handle the command '%s'." % (pieces[0]))
        
        

    print "Created the script pipelineScript.py in %s.\nWhen the script is run the final files will be:\n'%s'." % (
                                                                                outputDir, currentFile1)
        

def readScriptActions(actionFile):
    """Reads the script actions in from a text file."""
    try:
        actions = open(actionFile).read()
        return actions.strip()
    except IOError:
        print "Unable to open the file '%s' for script actions." % actionFile
        sys.exit(1)
        
def getOutputDir(inputFile1, inputFile2):
    """Determines the directory containing both files (must the same)."""
    
    if not os.path.exists(inputFile1):
        raise Exception("InputFile1 ('%s') does not exist." % (inputFile1))
    outputDir1 = os.path.dirname(os.path.abspath(inputFile1))
    if inputFile2:
        if not os.path.exists(inputFile2):
            raise Exception("InputFile2 ('%s') does not exist." % (inputFile2))
        outputDir2 = os.path.dirname(os.path.abspath(inputFile2))
        if outputDir1 != outputDir2:
            raise Exception("Both input files must reside in the same directory.\n  InputFile1 is '%s'.\n  InputFile2 is '%s'.\n" % (inputFile1, inputFile2))
        
    return outputDir1

def writeHeader(sf, inputFile1, inputFile2, fileType1, fileType2, outputDir, scriptActions):
    """Writes the introductory lines to the driver script."""
    
    printVars = {}
    printVars["if1"] = inputFile1
    printVars["if2"] = inputFile2
    printVars["ff1"] = fileType1
    printVars["ff2"] = fileType2
    printVars["out"] = outputDir
    printVars["act"] = "\n#      ".join(scriptActions.split("\n"))
    printVars["user"] = getpass.getuser()
    printVars["day"] = time.strftime("%a %m/%d/%y", time.localtime())
    printVars["time"] = time.strftime("%H:%M:%S", time.localtime())
    printVars["sd"] = config.SRC_DIRECTORY
    printVars["pd"] = config.PIPELINE_DIRECTORY
    sf.write(SCRIPT_OVERVIEW % printVars)

def writeCombineFiles(file1, file2, sf):
    tempName = os.path.splitext(file1)[0] + ".temp" + os.path.splitext(file1)[1]
    outName = os.path.splitext(file1)[0] + ".combined" + os.path.splitext(file1)[1]

    printVars = {}
    printVars["if1"] = file1
    printVars["if2"] = file2
    printVars["ot"] = tempName
    printVars["of"] = outName
    sf.write(SCRIPT_COMBINE_FILES % printVars)

    return outName

def writeSingleQualityFilter(file1, line, sf, offset):
    tempName1 = os.path.splitext(file1)[0] + ".temp.fq"
    filteredName1 = os.path.splitext(file1)[0] + "_flt.fq"

    numBases = config.DEFAULT_QUALITY_NUM_BASES
    threshold = config.DEFAULT_QUALITY_THRESHOLD
    pieces = line.split()
    if len(pieces) > 1:
        numBases = int(pieces[1])
    if len(pieces) > 2:
        threshold = int(pieces[2])
    if len(pieces) > 3:
        offset = int(pieces[3])

    printVars = {}
    printVars["if1"] = file1
    printVars["ot1"] = tempName1
    printVars["of1"] = filteredName1
    printVars["nb"] = numBases
    printVars["t"] = threshold
    printVars["os"] = offset
    sf.write(SCRIPT_QUALITY_FILTER_SINGLE % printVars)

    return filteredName1

    

def writeQualityFilter(file1, file2, line, sf, offset):
    tempName1 = os.path.splitext(file1)[0] + ".temp.fq"
    tempName2 = os.path.splitext(file2)[0] + ".temp.fq"
    filteredName1 = os.path.splitext(file1)[0] + "_flt.fq"
    filteredName2 = os.path.splitext(file2)[0] + "_flt.fq"

    numBases = config.DEFAULT_QUALITY_NUM_BASES
    threshold = config.DEFAULT_QUALITY_THRESHOLD
    pieces = line.split()
    if len(pieces) > 1:
        numBases = int(pieces[1])
    if len(pieces) > 2:
        threshold = int(pieces[2])
    if len(pieces) > 3:
        offset = int(pieces[3])

    printVars = {}
    printVars["if1"] = file1
    printVars["if2"] = file2
    printVars["ot1"] = tempName1
    printVars["ot2"] = tempName2
    printVars["of1"] = filteredName1
    printVars["of2"] = filteredName2
    printVars["nb"] = numBases
    printVars["t"] = threshold
    printVars["os"] = offset
    sf.write(SCRIPT_QUALITY_FILTER % printVars)

    return filteredName1, filteredName2

def writeConvertToFasta(inputFastq, sf):
    if not inputFastq:
        return None
    
    tempName = os.path.splitext(inputFastq)[0] + ".temp.fa"
    fastaName = os.path.splitext(inputFastq)[0] + ".fa"
    
    printVars = {}
    printVars["of"] = fastaName
    printVars["if"] = inputFastq
    printVars["ot"] = tempName
    sf.write(SCRIPT_CONVERT_FASTA % printVars)
    
    return fastaName

def writeFilterLZW(inputFasta, line, sf):
    if not inputFasta:
        return None
    
    # figure out what the person wants to do
    pieces = line.split(" ")
    threshold = config.DEFAULT_LZW_THRESHOLD
    if len(pieces) == 2:
        threshold = float(pieces[1])
    elif pieces > 2:
        raise Exception("Unable to understand line '%s'.  LZW filtering expects only one parameter, the lzw ratio threshold." % (line))
    
    # create the output name
    thisAction = "_lzw" + str(threshold)[2:]
    tempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.fa"
    outputName = os.path.splitext(inputFasta)[0] + thisAction + ".fa"
    
    # do the action
    printVars = {}
    printVars["of"] = outputName
    printVars["if"] = inputFasta
    printVars["ot"] = tempName
    printVars["th"] = threshold
    sf.write(SCRIPT_LZW % printVars)
    
    return outputName

def writeRemoveNs(inputFasta, line, sf):
    if not inputFasta:
        return None

    # figure out what the person wants to do
    pieces = line.split()
    threshold = config.DEFAULT_REMOVE_N
    rep_threshold = config.DEFAULT_HOMOPOLYMER_THRESHOLD
    if len(pieces) == 2:
        threshold = int(pieces[1])
    elif len(pieces) == 3:
        rep_threshold = int(pieces[2])
    elif len(pieces) > 3:
        raise Exception("Unable to understand line '%s'.  Removing N's expects two parameters, the number of Ns and the length of homopolymer repeat." % (line))

    # create the output names
    thisAction = "_n" + str(threshold)
    tempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.fa"
    outputName = os.path.splitext(inputFasta)[0] + thisAction + ".fa"

    # do the action
    printVars = {}
    printVars["of"] = outputName
    printVars["if"] = inputFasta
    printVars["ot"] = tempName
    printVars["th"] = threshold
    printVars["rth"] = rep_threshold
    sf.write(SCRIPT_REMOVE_N % printVars)

    return outputName


def writeFilterFromBowtie(outputDir, input1, input2, fileType, line, numProcessors, sf, delimiter):

    # figure out what the person wants to do
    pieces = line.split(" ")
    if len(pieces) < 2:
        raise Exception("Bowtie filter lines are expected in the format bowtie db filterParams | bowtieParams' but the line '%s' doesn't specify the database" % (line))

    try:
        bowtieDB = config.BOWTIE_DATABASES[pieces[1]]
    except KeyError:
        raise Exception("Unable to find '%s' in the set of BOWTIE databases.  Valid entries are:\n\t%s" % (pieces[1],
                                              "\n\t".join(BOWTIE_DATABASES.keys())))

    

    # get the BOWTIE and filter params
    linePieces = line.split("|")
    filterParams = linePieces[0]
    bowtieParams = ""
    if len(linePieces) > 1:
        bowtieParams = linePieces[1]
    if fileType == pipelineUtils.FILE_TYPE_FASTA:
        bowtieParams += " -f "
        fileExt = ".fa"
    else:
        fileExt = ".fq"

    filterParams = filterParams.split(" ")[2:]
    # the bowtie filter isn't as complex as the blat/blast filter -- it's a simple
    # yes/no: if something has an alignment, it's a match
    doDivide=False
    pairedHits = True
    pairedMisses = False
    useMisses = True
    for p in filterParams:
        if len(p) == 0:
            continue

        try:
            (name, value) = p.split("=")
        except:
            raise Exception("The line '%s', in particular the filter param '%s' was unable to interpreted.  Filter params are expected to be in name=value format." % (line.strip(), p))

        if name == "doDivide":
            doDivide = value.startswith("t") or value.startswith("T")
        elif name == "pairedHits":
            pairedHits = value.startswith("T") or value.startswith("t")
        elif name == "pairedMisses":
            pairedMisses = value.startswith("T") or value.startswith("t")
        elif name == "useMisses":
            useMisses = value.startswith("T") or value.startswith("t")

    if pairedHits and pairedMisses:
        raise Exception("You can include paired ends with only one of hits or misses, not both!")

    # create the output name
    thisAction = "_c" + config.BOWTIE_DB_ABBREV[pieces[1]]
    if not useMisses:
        thisAction += "Hits"
    outBowtieName = os.path.splitext(input1)[0] + thisAction + ".bwt"
    outBowtieTempName = os.path.splitext(input1)[0] + thisAction + ".temp.bwt"
    outputName1 = os.path.splitext(input1)[0] + thisAction + fileExt
    outputTempName1 = os.path.splitext(input1)[0] + thisAction + ".temp" + fileExt
    bowtieLogFile = os.path.splitext(input1)[0] + thisAction + ".bowtieLog.txt"
    outputName2 = ""
    outputTempName2 = ""
    if input2:
        outputName2 = os.path.splitext(input2)[0] + thisAction + fileExt
        outputTempName2 = os.path.splitext(input2)[0] + thisAction + ".temp" + fileExt

    if useMisses:
        filterParams = "delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits1=None, printHits2=None, printMisses1='%s', printMisses2='%s'" % (delimiter, pairedHits, pairedMisses, outputTempName1, outputTempName2)
    else:
        filterParams = "delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits1='%s', printHits2='%s', printMisses1=None, printMisses2=None" % (delimiter, pairedHits, pairedMisses, outputTempName1, outputTempName2)

    print "Line was: '%s'" % (line)
    print "   delimiter='%s', pairedHits=%s, pairedMisses=%s, usesMisses=%s" % (delimiter, pairedHits, pairedMisses, useMisses)
    print "   bowtieParams are: '%s'" % (bowtieParams)
    


    # do the action
    printVars = {}
    printVars["ofb"] = outBowtieName
    printVars["if1"] = input1
    printVars["if2"] = input2
    printVars["otb"] = outBowtieTempName
    printVars["td"] = bowtieDB
    printVars["bp"] = bowtieParams
    printVars["off1"] = outputName1
    printVars["off2"] = outputName2
    printVars["fp"] = filterParams
    printVars["otf1"] = outputTempName1
    printVars["otf2"] = outputTempName2
    printVars["tmp"] = outputDir
    printVars["nn"] = numProcessors
    printVars["log"] = bowtieLogFile
    printVars["dh"] = doDivide
    printVars["ft"] = fileType
    sf.write(SCRIPT_BOWTIE % printVars)
    if input2:
        sf.write(SCRIPT_BOWTIE_PAIR % printVars)
    
    return outputName1, outputName2
    

def writeFilterFromBowtie2(outputDir, input1, input2, fileType, line, numProcessors, sf, delimiter):

    # figure out what the person wants to do
    pieces = line.split(" ")
    if len(pieces) < 2:
        raise Exception("Bowtie2 filter lines are expected in the format bowtie2 db | bowtieParams' but the line '%s' doesn't specify the database" % (line))

    try:
        bowtieDB = config.BOWTIE2_DATABASES[pieces[1]]
    except KeyError:
        raise Exception("Unable to find '%s' in the set of BOWTIE2 databases.  Valid entries are:\n\t%s" % (pieces[1],
                                              "\n\t".join(BOWTIE2_DATABASES.keys())))

    

    # get the BOWTIE
    linePieces = line.split("|")
    if len(linePieces) > 1:
        bowtieParams = linePieces[1]
    else:
        bowtieParams = ""
    if fileType == pipelineUtils.FILE_TYPE_FASTA:
        bowtieParams += " -f "
        fileExt = ".fa"
    else:
        fileExt = ".fq"

    # create the output name
    thisAction = "_c" + config.BOWTIE2_DB_ABBREV[pieces[1]]
    outBowtieName = os.path.splitext(input1)[0] + thisAction + ".sam"
    outBowtieTempName = os.path.splitext(input1)[0] + thisAction + ".temp.sam"
    outputName1 = os.path.splitext(input1)[0] + thisAction + fileExt
    outputTempName1 = os.path.splitext(input1)[0] + thisAction + ".temp" + fileExt
    bowtieLogFile = os.path.splitext(input1)[0] + thisAction + ".bowtie2Log.txt"

    print "Line was: '%s'" % (line)
    print "   bowtieParams are: '%s'" % (bowtieParams)

    # do the action
    printVars = {}
    printVars["ofb"] = outBowtieName
    printVars["if1"] = input1
    printVars["if2"] = input2
    printVars["otb"] = outBowtieTempName
    printVars["td"] = bowtieDB
    printVars["bp"] = bowtieParams
    printVars["un"] = outputName1
    printVars["tmp"] = outputDir
    printVars["nn"] = numProcessors
    printVars["log"] = bowtieLogFile
    sf.write(SCRIPT_BOWTIE2 % printVars)    

    if input2:
        outputName1 = os.path.splitext(input1)[0] + thisAction + ".1" + fileExt
        outputName2 = os.path.splitext(input1)[0] + thisAction + ".2" + fileExt
        return outputName1, outputName2
    else:
        return outputName1, None
    

def  writeFilterFromBlat(outputDir, inputFasta, line, numProcessors, sf, delimiter):
    if not inputFasta:
        return None
    
    # figure out what the person wants to do
    pieces = line.split(" ")
    if len(pieces) < 2:
        raise Exception("Blat filter lines are expected in the format 'blat db filterParams | blastParams' but the line '%s' doesn't specify the database." % (line))
    
    try:
        blatDB = config.BLAT_DATABASES[pieces[1]]
    except KeyError:
        raise Exception("Unable to find '%s' in the set of BLAT databases.  Valid entries are:\n\t%s" % (pieces[1], "\n\t".join(BLAT_DATABASES.keys())))

    # get the BLAT and filter params
    linePieces = line.split("|")
    filterParams = linePieces[0]
    blatParams = ""
    if len(linePieces) > 1:
        blatParams = linePieces[1]
    #print "At the beginning, blatParams: '%s'" % (blatParams)
    filterParams = filterParams.split(" ")[2:]
    # analyze the filter params, and add to the blatParams where necessary
    # set up the filter params at their defaults, then adjust based on the user's line and
    #     based on the DEFAULT_BLAT_FILTER_PARAMS
    minPercent = None
    minCoverage = None
    minTotalPercent = None
    pairedHits = True
    pairedMisses = False
    useMisses = True
    doDivide=False
    # get the user's preferences
    for p in filterParams:
        if len(p) == 0:
            continue

        try:
            (name, value) = p.split("=")
        except:
            raise Exception("The line '%s', in particular the filter param '%s' was unable to be interpreted." % (line.strip(), p))

        #print name, value, blatParams

        if name == "minPercent":
            minPercent = float(value)/100
            if minPercent < 0.01 or minPercent > 1:
                raise Exception("The percent ID must be between 1 and 100 inclusive!  Current value is '%s'" % (minPercent*100))
            #blatParams += " -minIdentity=%s" % minPercent*100
            #print "ADDED minPercent!", minPercent, name, value
        elif name == "minCoverage":
            minCoverage = float(value)/100
            if minCoverage < 0 or minCoverage > 1:
                raise Exception("The minimum coverage must be between 0 and 100 inclusive!  Current value is '%s'" % (minCoverage*100))
        elif name == "minTotalPercent":
            minTotalPercent = float(value)/100
            if minTotalPercent < 0.01 or minTotalPercent > 1:
                raise Exception("The minimum total coverage must be between 1 and 100 inclusive!  Current value is '%s'" % (minTotalPercent*100))
            blatParams += " -minIdentity=%s" % (minTotalPercent*100)
            print "added minTotalPercert", minTotalPercent
        elif name == "pairedHits":
            pairedHits = value.startswith("T") or value.startswith("t")
        elif name == "pairedMisses":
            pairedMisses = value.startswith("T") or value.startswith("t")
        elif name == "useMisses":
            useMisses = value.startswith("T") or value.startswith("t")
        elif name == "doDivide":
            doDivide = value.startswith("T") or value.startswith("t")

    #print "after filter params, blatParams='%s'" % (blatParams)
    if pairedHits and pairedMisses:
        raise Exception("You can include paired ends with only one of hits or misses, not both!")

    # set the filter defaults
    # CHANGE THIS CODE IF YOU WANT THE DEFAULT BLAT ACTION TO BE DIFFERENT
    if not minPercent and not minCoverage and not minTotalPercent:
        minTotalPercent = config.DEFAULT_BLAT_THRESHOLD
        
    # allow the user to override the ooc file selection.  Still requires an ooc file to be used, but
    # at least the user can use other tile sizes as long as a new ooc file is also specified.
    if line.find("-ooc") < 0:
        oocFile = config.BLAT_OOC_FILES[pieces[1]]
    else:
        oocFile = ""
    
    # most params are just passed to the next step, but we want to know about fastmap here for output name stuff
    useFastmap = line.find("-fastMap") >= 0
        
    # create the output name
    thisAction = "_c" + config.BLAT_DB_ABBREV[pieces[1]]
    if not useMisses:
        thisAction += "Hits"
    outBlatName = os.path.splitext(inputFasta)[0] + thisAction + ".psl"
    outBlatTempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.psl"
    outputName = os.path.splitext(inputFasta)[0] + thisAction + ".fa"
    outputTempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.fa"
    blatLogFile = os.path.splitext(inputFasta)[0] + thisAction + ".blatLog.txt"
    if useMisses:
        filterParams = "minPercent=%s, minCoverage=%s, minTotalPercent=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits=None, printMisses='%s'" % (minPercent, minCoverage, minTotalPercent, delimiter, pairedHits, pairedMisses, outputTempName)
    else:
        filterParams = "minPercent=%s, minCoverage=%s, minTotalPercent=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits='%s', printMisses=None" % (minPercent,minCoverage, minTotalPercent, delimiter, pairedHits, pairedMisses, outputTempName)
    #blatParams += " ".join(pieces[2:])
    # for the blat params, just add the defaults unless the user has overridden them
    for p in config.DEFAULT_BLAT_PARAMS:
        try:
            name, value = p.split("=")
        except:
            name = p
        # if the user's blat params do not include the name of the param in
        # the default params, then add the default param.  In other words, only
        # add the default param if the user didn't try to override it.
        if blatParams.find(name) < 0:
            blatParams = blatParams + " " + p

    print "Line was: '%s'" % (line)
    print "   DEFAULT_BLAT_PARAMS are: '%s'" % (config.DEFAULT_BLAT_PARAMS)
    print "   filter params are: minPercent=%s, minCoverage=%s, minTotalPercent=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, usesMisses=%s" % (minPercent, minCoverage, minTotalPercent, delimiter, pairedHits, pairedMisses, useMisses)
    print "   blatParams are: '%s'" % (blatParams)
    


    # do the action
    printVars = {}
    printVars["ofb"] = outBlatName
    printVars["if"] = inputFasta
    printVars["otb"] = outBlatTempName
    printVars["td"] = blatDB
    printVars["bp"] = blatParams
    printVars["off"] = outputName
    printVars["fp"] = filterParams
    printVars["otf"] = outputTempName
    printVars["ooc"] = oocFile
    printVars["tmp"] = outputDir
    printVars["nn"] = numProcessors
    printVars["log"] = blatLogFile
    printVars["dh"] = doDivide
    sf.write(SCRIPT_BLAT % printVars)
    
    return outputName

def writeFilterFromBlast(outputDir, inputFasta, line, numProcessors, sf, delimiter):
    if not inputFasta:
        return None
    
    # figure out what the person wants to do
    pieces = line.split(" ")
    if len(pieces) < 2:
        raise Exception("Blast filter lines are expected in the format 'blast db filterParams | blastParams' but the line '%s' doesn't specify the database." % (line))
    
    try:
        blastDB = config.BLAST_DATABASES[pieces[1]]
    except KeyError:
        raise Exception("Unable to find '%s' in the set of BLAST databases.  Valid entries are:\n\t%s" % (pieces[1], "\n\t".join(config.BLAST_DATABASES.keys())))
        
    # get the BLAST and the filter params
    linePieces = line.split("|")
    filterParams = linePieces[0]
    blastParams = ""
    if len(linePieces) > 1:
        blastParams = linePieces[1]
    filterParams = filterParams.split(" ")[2:]
    # analyze the filter params, and add to the blastParams where necessary
    # set up the filter params at their defaults, then adjust based on user's line and
    #    based on the DEFAULT_BLAST_FILTER_PARAMS
    minPercent = None
    minLength = None
    minNumIds = None
    maxEval = None
    minBitScore = None
    delimiter = "#0/"
    pairedHits = True
    pairedMisses = False
    useMisses = True
    # first get the user's preferences
    for p in filterParams:
        if len(p) == 0:
            continue
        
        try:
            (name, value) = p.split("=")
        except:
            print "The line '%s', in particular the filter param '%s' was unable to be interpreted" % (line.strip(), p)
            raise
        if name == "minPercent":
            minPercent = float(value)
            if minPercent < 0 or minPercent > 100:
                raise Exception("The percent ID must be between 0 and 100 inclusive!  Current value: '%s'" % (minPercent))
            blastParams += " -perc_identity " + value
        elif name == "minLength":
            minLength = int(value)
            if minLength < 1:
                raise Exception("The minLength must be at least 1!  Current value: '%s'" % (minLength))
        elif name == "minNumIds":
            minNumIds = int(value)
            if minNumIds < 1:
                raise Exception("The number of identities must be at least 1!  Current value: '%s'" % (minNumIds))
        elif name == "maxEval":
            maxEval = float(value)
            if maxEval < 0:
                raise Exception("The evalue must be greater than 0!  Current value: '%s'" % (maxEval))
            blastParams += " -evalue " + value
        elif name == "minBitScore":
            minBitScore = int(value)
            if minBitScore < 0:
                raise Exception("The bit-score must be positive!  Current value: '%s'" % (minBitScore))
        elif name == "pairedHits":
            pairedHits = value.startswith("T") or value.startswith("t")
        elif name == "pairedMisses":
            pairedMisses = value.startswith("T") or value.startswith("t")
        elif name == "useMisses":
            useMisses = value.startswith("T") or value.startswith("t")
    if pairedHits and pairedMisses:
        raise Exception("You can include paired ends with only one of hits or misses, not both!")
    
    # set the filter defaults
    # CHANGE THIS CODE IF YOU WANT THE DEFAULT BLAST ACTION TO BE DIFFERENT
    if not minPercent and not minLength and not minNumIds and not maxEval and not minBitScore:
        maxEval = config.DEFAULT_BLAST_THRESHOLD

    # for the blast params, just add the defaults unless the user has overridden them
    for p in config.DEFAULT_BLAST_PARAMS:
        try:
            name, value= p.split(" ")
        except:
            name = p
        # if the user's blat params do not include the name of the param in
        # the default params, then add the default param.  In other words, only
        # add the default param if the user didn't try to override it.
        if blastParams.find(name) < 0:
            blastParams = blastParams + " " + p

    print "Line was: '%s'" % (line)
    print "   DEFAULT_BLAST_PARAMS are: '%s'" % (config.DEFAULT_BLAST_PARAMS)                                                                
    print "   filterParams are (minPercent=%s, minLength=%s, minNumIds=%s, maxEval=%s, minBitScore=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, useMisses=%s)" % (minPercent, minLength, minNumIds, maxEval, minBitScore, delimiter, pairedHits, pairedMisses, useMisses) 
    print "   blastParams are: '%s'" % (blastParams)


    # create the output name
    thisAction = "_c" + config.BLAST_DB_ABBREV[pieces[1]]
    if not useMisses:
        thisAction += "Hits"
    outBlastName = os.path.splitext(inputFasta)[0] + thisAction + ".bln"
    outBlastTempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.bln"
    blastLogFile = os.path.splitext(inputFasta)[0] + thisAction + ".blastLog.txt"
    outputName = os.path.splitext(inputFasta)[0] + thisAction + ".fa"
    outputTempName = os.path.splitext(inputFasta)[0] + thisAction + ".temp.fa"
    if useMisses:
        filterParams = "minPercent=%s, minLength=%s, minNumIds=%s, maxEval=%s, minBitScore=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits=None, printMisses='%s'" % (minPercent, minLength, minNumIds, maxEval, minBitScore, delimiter, pairedHits, pairedMisses, outputTempName)
    else:
        filterParams = "minPercent=%s, minLength=%s, minNumIds=%s, maxEval=%s, minBitScore=%s, delimiter='%s', pairedHits=%s, pairedMisses=%s, printHits='%s', printMisses=None" % (minPercent, minLength, minNumIds, maxEval, minBitScore, delimiter, pairedHits, pairedMisses, outputTempName)
    
    # do the action
    printVars = {}
    printVars["ofb"] = outBlastName
    printVars["if"] = inputFasta
    printVars["otb"] = outBlastTempName
    printVars["td"] = blastDB
    printVars["bp"] = blastParams
    printVars["off"] = outputName
    printVars["fp"] = filterParams
    printVars["otf"] = outputTempName
    printVars["tmp"] = outputDir
    printVars["nn"] = numProcessors
    printVars["log"] = blastLogFile
    sf.write(SCRIPT_BLAST % printVars)
    
    return outputName



##############################################
if __name__ == "__main__":
    sys.exit(main(None)) 

